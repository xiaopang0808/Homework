asciiֵΪ0-127еľ󲿷֣һЩᱻfeofΪȡʧܣȥһЩַ
	3500
	עtxtĵANSIutf-8ʽ£ֲͬĹ룬Ƕܳɹ
	ѾMD5У飬sourceĵɵunencryptĵһ¡

1
22
3333
44444444
5555555555555555
66666666666666666666666666666666
7777777777777777777777777777777777777777777777777777777777777777
88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888
9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~

һҶʮ߲˾ż˵ڸɿʿŴ´С
ڽɽǧڸ׾÷Ϧô֮ʬҲŮϰ
Ԫרľ֧̫ȮƥͱȻֹ
ԱˮţëʲƬͻԽצ鸸ӽ׷ַ
Ƿ絤ڷﹴΪ䶩ƻĳͿ׶ӰȰ˫
ʾĩδ˰ǹȥŽڱɱʯƽռҵ
˧ҵĿҶ궣ʷֵֻ߶̾ʧ̴ǰ
Ϻ˦ӡ־Ҳ᷸⴦֭ͷѨ
дѵѶ˾ūƤ߷ʥ̨ìĸ˿ʽ̶
¼ۿִɨﳡâ֥ӻȨЭѹаٴ
ҳҴɼйаʦӹ⵱ųͬ
췫ȶǨΰƹŷӼ˼۷ݻ
»αѪƺȫɱүɡΣѮּɫ׳
ׯ뽻²ʴ򲢹׵ݺ۽æլְ
ũѰѸս績Ϸۻ˼Լ
ѲŪνԶΥ˷̳žַ߳ӹץТ
Ͷؿӷ־Ťѱȴѿ۷ҲԷ«Ϳո˸ܶŲĴӼ
ҽ񻹼ẵʱ԰Χѽ
ԱԴذɺʲ붤ͺ˽ÿεӶ
סλ۷ϣ׺ڲζǳ̽ɾѵӭϵ
Զ״ĶӦұмӵɳַûǿ
κξ֤ʶ鼴βپָżɼ½
Ŭ̾ɴɸٲݷֽƷ¿Ŧ滷ֱĨ£μ
̹Ѻ߶ӵ־Ʊ̧ȡïƻӢֱ
Ѿé֦ǹɥ´ޱ̬ŷ¢޺
תնϳЩ²߹ζװҸӽ
뿭ܷͼ֪ԹθѺͼί̹ʹֶƾ
˾ֲ̰ƶ֫ɷʷвܻ
úαǱ侩ҹ׼Ͼäſբ֣ȯ
¯ĭǳйմͲעкӾвβѧڶٿ
ʵʫ緿ϳӻѯ꽨¼ӽˢҳϹ½ùý
ʼݲμϸʻ֯פܾഺ䲣͹ҷԵ
ͦ˩ʰָƴڰŲĳݼãٹʺҩݱ
ҪשˣǣѻԱսʡ
գðӳηſθϺ˼Ʒҧ̿Ͽ
ǳӸԿжװݿѡظͶα˳ޱ
׷ŻȪ׷ܴɺʳ赨ʤʨóԹ
ʴȱ佫ͤȼͥ߰ʩŷǰ
ըǶϴǢȾ޻Ũǡպ޾پҹ
ͻԿ͹ף˵п˼ѶüԺŭܺ
ӯµݰ޽ƽͳ̩زյԲظ
׽żȿֺܵĪɻͩ
Уٶ贽Ĵԭ˽ν϶ٱ²Ǽɹ
Ѽڿ޶շԲǮǯǦȱ˵г
ȳ͸Цծֵ㵹Ⱦ㳫򸩱뽡乪Ϣͽ콢հ㺽;õ
̴֬ظེǷ˥ϯ׼֢ƣЧվ
ʾƿȭ濾淳̵ԾƺͿԡ
ӿĻúխװ۱˭ԩ̸
չмͨԤɣڽŵ
ӿ̽ݾְջܾѾƼӪе÷ͰȸƱ
ˬϮʢѩȸó׳ҰľԾ۳ΨոȦͭ
ƱѷƳż͵ͣƫٵ̴биϤŲ
󹻲èڹݴռȿӹ¹¾Ÿճ
Һϧѵ辪ҹ߿ܼҤıѻ
浰¡άٰԽ̲
ϲ徾Ԯø§˹ɢϾ䳯ֲɭν
ػݻƳӲȷֳűϻԳ羧
Ѻιñ̺ʣԳϡ˰
ɸͲݰƱ½ֳѭͧ淬Ƣǻ³Ȼװ
ʹͯշۺʪ¿ʻ̸ȷ߻Ŷ修
Ѵԣȹлҥǫǿ϶ɩǶлƭԵİЯ
ҡ̯ȵĹĻ׽뻱¥аµ
䶽˯ǱůЪտ·ǲɤִസⰫ
ǳǩپɵ΢ңȸȴ⽴̵ܴú
ĮԴϪ̲ȺӼ޵ǽƲδݽ
ľժˤ۱ĽĺģեԸѿӬ֩׬¶
űòĤúڸ߶쾫ǸϨƯ©կ
۴ܵ˺Ȥ˳ŲײЬߺӣƮù
ϹӰ̤ٵī򿿵ƪƧϥĦǱ
οнѲĬĥǸȼ
ڱܽɴϲ˪ϼƵ뷱Ӯ㿷޸ӥʶײ
ҫ¼ħ¶ҹذؤزؼߵ˰͹¬ߴʸ
էߺ͢ױѴȶϾ
ѱҾͿٶ󹯰տܽέоɼ辸ϻ±Ф֨Ż
Ǻǿض˱ĵӵŴѸ鱷ͮٱ®̭ڲ׻
թƨ׹梶γõԿƺš׾Ĵɻ̦ö
Ź׿꼰놪ؿ˱ձ³ޱɲٷ
ͰűåŢӳ뻡ªİķʭ
԰ɺÿЮײӫջդϲɰ
ŸŰѫӴĸƶվťձζ̥
쪹¦˸ѻ½ʺѷҦ麧Ű
乡溴ԬƴֿͱݩçӨݺ˨Φ׮ѳ벸
ް¸߼íʰ޾Ҩ򱪰
ŧԧԹիɴɸлӽɬŵ̻׻ˡ俥
ŴഷⲺҴȢήөǬ
˶ݿ­ֺơɶХߴޱӤա
ϳýջ˿㲰϶Ḭݻ˲Ȭֲ캸
ʻԨٵ̺ϵгɸνξĴ±׺
߿ҾҼɦļٺҬ׵ڼ
˻ѸǶпҸ
⬱ض챺河㵻ԢѾͰϬýµ
ɧɪĹƸѥбШҵƵϾζ
Ӽê׶ǶǿԳӱɷ
į޹ϱͽ׸ġᰪεŽ͵
̼ԯϽӻ᣶Ѭɮô̷
ӧôܶ׫̷Ϸ㴼İ˻Ыٴ
¨̶̱ʰ˳㾰Ǵ׺ԥԺѦޱ
溲جư޼ǭ´žȳǱи
̴ֺ˲̣ͫ󰺿κܻվӰųź
հٽ赴ĢзѢΡŴƩպȿ
#include <iostream>
#define N 256               // 볤ȣ+1 / Ҫĸ
							//-128Ӧַ127Ӧַ256ַ(ȨֱֵΪ124...ʱĹ볤Ȼﵽ255)
#define inf 0x7fffffff      // intֵ

using namespace std;

typedef signed char ElemType;   // ڵֵ ʹsigned charЩcharʶΪunsigned char
typedef int QType;      		// ȨصͣȨÿֵַĴ

/* --------ûж϶ȡļʧܵ-------- */

/* Ľڵ ʵ*/
typedef struct
{
	ElemType data;
	QType weight;
	int parent;
	int lchild, rchild;
} HTNode;

/* ͣʹã */
typedef struct
{
	char cd[N];     	// ɵĹ
	int start;          // 뿪ʼλ
} HCode;

/* ܹĽڵ ʵ*/
/* ҲһùΪֻ֣˵Ƕ*/
typedef struct Node
{
	ElemType data;
	Node *lchild, *rchild;
} BTNode;

/* ½ڵ */
void CreateBTNode(BTNode*& b)
{
	b = new BTNode;
	b->lchild = b->rchild = NULL;
	b->data = -1;       // ֵΪ-1ʾӸڵ㵽˴ĳһ
}

/* ʹȨֵĽڵ㽨 */
void CreateHT(HTNode ht[], int n0) /*n0 ԭʼڵҲյҶӽڵ */
{
	int i, j, lnode, rnode;
	QType min1, min2;          			 // СȨֵ
	for (i = 0; i < 2 * n0 - 1; ++i)    // ʼĬ϶Ҷӽڵ㣬ûҺ
		ht[i].parent = ht[i].lchild = ht[i].rchild = -1;
		
	for (i = n0; i < 2 * n0 - 1; ++i)   // n0ʼ
	{
		min1 = min2 = inf;              // ĬСֵΪ޴min1洢minнСǸmin1ֵ
		lnode = rnode = -1;             // ĬûҵҺ
		for (j = 0; j < i; ++j)         // Сֵ
		{
			if (-1 == ht[j].parent)     // ҪҶӽڵ
			{
				if (ht[j].weight < min1)    // ȻminСֵС
				{
					min2 = min1;            // min1ֵmin2
					rnode = lnode;          // ͬʱmin1Ľڵlnode¼Һӵrnode
					min1 = ht[j].weight;    // min1ֵȻminнСǸ
					lnode = j;              // ¼ýڵΪ
				}
				else if (ht[j].weight < min2)   // if min1 <= ht[j].weight < min2
				{
					min2 = ht[j].weight;        // min2
					rnode = j;                  // ҺҲ
				}
			}
		}
		ht[i].weight = min1 + min2;             // min1min2¼ľСȨֵ
		ht[i].lchild = lnode;                   // ½ڵҺӾminӦĽڵ
		ht[i].rchild = rnode;
		ht[lnode].parent = ht[rnode].parent = i;    // ¼ǵ˫׽ڵ
	}
}

/* ù¼ */
void CreateHCode(HTNode ht[], HCode hcd[], int n0)
{
	int i, f, c;
	HCode hc;
	for (i = 0; i < n0; ++i)    // 0 - n0-1 ¼ľҶӽڵ㣬ҶӽڵҸڵ㣬ͬʱ¼
	{
		hc.start = n0;          // ʼʼλΪһλ
		c = i;                  // c¼ǰڵ±
		f = ht[i].parent;       // f¼ǰڵ˫׽ڵ±

		while (f != -1)         // ýڵ㲻Ǹڵʱɺֻиڵû˫׽ڵ㣩
		{
			if (ht[f].lchild == c)  // ýڵ˫׽ڵӣô0
				hc.cd[hc.start--] = '0';
			else
				hc.cd[hc.start--] = '1';    // ֮Ϊ1
			c = f; f = ht[c].parent;        // ǰڵ˫׽ڵλãͬʱfΪǰڵ˫׽ڵ
		}
		++hc.start;                     // startһ
		hcd[i] = hc;                    // յõĹǵiҶӽڵĹ
	}
}

/* ݹ빹ܶڽ */
/* ӸڵΪӶӦĽڵ */
void addNode(BTNode* b, char* s, int e)
{
	if (*s == '0')  // 뵱ǰλ0Ҫȥ
	{
		if (!b->lchild) // 治ڣھʹ
			CreateBTNode(b->lchild);
		addNode(b->lchild, s+1, e); // һλ
	}
	else if (*s == '1') // Ҫȥ
	{
		if (!b->rchild)
			CreateBTNode(b->rchild);
		addNode(b->rchild, s+1, e);
	}
	else    // *s == '\0' ַĩβ
		b->data = e;    // Ϊڵ㸳ֵ֤Ӹڵ㵽˽ڵĹ ֵe Ӧַ
}

/* 1. ͳִַ */
void statAndCalc()
{
	int i, j;
	FILE *in, *out;
	ElemType ch;
	HTNode ht[N * 2];           // Ľڵʵ Ҷӽڵ * 2 - 1
	HCode hcd[N];				// 256ֱַӦsigned char-128~127256ֹ
	int cnt[N] = {0}, cur = 0;  // cntͳ256ַĳִcurճֵַĸ
	
	for (i = 0, j = -128; i < 256; ++i, ++j)    // ȳʼht[0]  0-128 = -128Ӧַht[255] 127Ӧַ
		ht[i].data = j;

	in = fopen("source.txt", "r");              // sourceļ
	while ( (ch = fgetc(in)) && !feof(in) )     // һcharһcharض
	{
		++cnt[ch+128];                          // ͬʱͳ -128Ӧcnt[0]
	}
	fclose(in);

	for (i = 0; i < 256; ++i)               // cnt飬ҳֵַֹʵ֣ǰڵ
	{
		if (cnt[i])     					// cnt[i] != 0
		{
			ht[cur].data = i - 128;         // ԭΪsigned charӦ -128 ~ 127
			ht[cur].weight = cnt[i];        // ȨֵǳֵĴ
			++cur;                          // cur¼ַֹĸ
		}
	}

	CreateHT(ht, cur);                      // 
	CreateHCode(ht, hcd, cur);              // ɶӦ

	out = fopen("code.txt", "w");
	for (i = 0; i < cur; ++i)              	    // ַӦ
	{
		fprintf(out, "%d ", (int)ht[i].data);   // Ϊֱ۲Щַʾsigned charתint
		for (j = hcd[i].start; j <= cur; ++j)
			fprintf(out, "%c", hcd[i].cd[j]);   // ӿʼβÿһλ
		fprintf(out, "\n");
	}
	fclose(out);
}

/* 2. code.txtsource.txt */
void encrypt()
{
	char code[N][N];    // Ķά飬code[200] 200-128=72Ӧַ ӦĹ  ַ
	int t;
	FILE *in, *out;
	ElemType ch;
	
	in = fopen("code.txt", "r");
	
	while (fscanf(in, "%d", &t) != EOF)     // code.txtжȡֵַĹ룬浽codeά
		fscanf(in, "%s", code[t+128]);      // ַ + 128 ܶӦ±0-255
		
	fclose(in);


	in = fopen("source.txt", "r");     
	out = fopen("encrypt.txt", "w");
	
	while ( (ch=fgetc(in)) && !feof(in))    // ݶȡĹ룬source.txtжȡԭģ
		fprintf(out, "%s", code[ch+128]);   // sourceжȡַ ӦĹ  ַ
		
	fclose(in); fclose(out);
}

/* 3. */
void unencrypt()
{
	int t;
	BTNode *bt, *p; CreateBTNode(bt);   // ʼһöǹ
	FILE *in, *out;
	ElemType ch;
	char tmp[N];      					// ʱ洢
	
	in = fopen("code.txt", "r");        
	
	while (fscanf(in, "%d", &t) != EOF)		// code.txtжȡÿһַɶӦĽڵ
	{
		fscanf(in, "%s", tmp);
		addNode(bt, tmp, t);            // ù룬ڶвϿ/Ѱҽڵ㣬ҵӦҶӽڵ㲢ֵ
	}
	
	fclose(in);
	

	in = fopen("encrypt.txt", "r");
	out = fopen("unencrypt.txt", "w");

	p = bt;                                 // pָǰڵ㣬һʼָڵ
	while ( (ch=fgetc(in)) && !feof(in))    // ɵĶȡģѰҶӦҶӽڵ
	{
		p = (ch == '0') ? p->lchild : p->rchild;    // ȡ'0'ǵĻǰڵpָ
		                                            // ǵĻȡľ'1'ˣǰڵָҺ
		if (p->data != -1)                          // ǰڵֵ
		{
			fprintf(out, "%c", p->data);            // ֵcharǺֵһҲûϵֻϳһ֣
			p = bt;                                 // ǰڵ»صĸڵ
		}
	}
	fclose(in); fclose(out);
}

int main()
{
	char ch;
	cout << "ҪĲ" << endl;
	cout << "0ν123" << endl;
	cout << "1: ĵÿֵַƵʣÿַɶӦĹ룬code.txt" << endl;
	cout << "2: Դsource.txtеÿַù滻encrypt.txtĵ" << endl;
	cout << "3encrypt.txtcode.txtıԭunencrypt.txtĵ" << endl;
	
	cin >> ch;
	switch(ch)
	{
		case '0': statAndCalc(); encrypt(); unencrypt(); break;
		case '1': statAndCalc(); break;
		case '2': encrypt(); break;
		case '3': unencrypt(); break;
		default: cout << "г" << endl; return 0;
	}
	
	cout << "ɹ" << endl;
	return 0;
}